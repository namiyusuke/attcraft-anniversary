---
// ====================================
// Import
// ====================================
// Config
import { SITE, COMPANY, SNS } from "../config";
import { schema } from "../functions/schema";

// Component
import GlobalHeader from "../components/global/GlobalHeader.astro";
import GlobalFooter from "../components/global/GlobalFooter.astro";

interface Props {
  title: string;
  description: string;
}

const { title, description } = Astro.props;
const jsonLd = schema(description);
---

<!doctype html>
<html lang="ja" data-script>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content={description} />
    <meta property="og:url" content={Astro.url} />
    <meta property="og:title" content={title} />
    <meta property="og:description" content={description} />
    <meta property="og:image" content={`${SITE.url}/ogp.png`} />
    <meta property="og:type" content="website" />
    <meta property="og:locale" content="ja_JP" />
    <meta property="og:site_name" content={SITE.name} />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content={SNS.twitter} />
    <meta name="format-detection" content="telephone=no, email=no, address=no" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Kaisei+Opti&display=swap" rel="stylesheet" />
    <link rel="canonical" href={Astro.url} />
    <link rel="icon" type="image/svg+xml" href={`${SITE.base}favicon.svg`} />
    <link rel="apple-touch-icon" sizes="180x180" href={`${SITE.base}apple-touch-icon.png`} />
    <link rel="stylesheet" href="./" />
    <title>{title}</title>
    <script>
      (function (d) {
        var config = {
            kitId: "vfo5azs",

            scriptTimeout: 3000,

            async: true,
          },
          h = d.documentElement,
          t = setTimeout(function () {
            h.className = h.className.replace(/\bwf-loading\b/g, "") + " wf-inactive";
          }, config.scriptTimeout),
          tk = d.createElement("script"),
          f = false,
          s = d.getElementsByTagName("script")[0],
          a;
        h.className += " wf-loading";
        tk.src = "https://use.typekit.net/" + config.kitId + ".js";
        tk.async = true;
        tk.onload = tk.onreadystatechange = function () {
          a = this.readyState;
          if (f || (a && a != "complete" && a != "loaded")) return;
          f = true;
          clearTimeout(t);
          try {
            Typekit.load(config);
          } catch (e) {}
        };
        s.parentNode.insertBefore(tk, s);
      })(document);
    </script>
    <script type="application/ld+json" set:html={jsonLd} is:inline />
    <script async src={`https://www.googletagmanager.com/gtag/js?id=${SITE.trackingId}`} is:inline></script>
    <script define:vars={{ trackingId: SITE.trackingId }} is:inline>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag("js", new Date());
      gtag("config", trackingId);
    </script>
  </head>
  <body class="bg-main">
    <GlobalHeader />
    <slot />
    <GlobalFooter />
  </body>
</html>
<style is:global>
  :root {
  }
</style>
<script>
  import { gsap } from "gsap";
  import Loading from "@assets/js/libs/Loading";
  import Toggle from "@assets/js/libs/Toggle";
  import Observer from "@assets/js/libs/Observer";
  new Observer(".js-observer");
  new Loading();
  new Toggle(".js-toggle");
  const htmlElement = document.documentElement;
  const addHiddenClass = () => {
    if (!htmlElement.classList.contains("is-hidden")) {
      htmlElement.classList.add("is-hidden");
    }
  };
  const container = document.getElementById("scroll-container");
  const content = document.getElementById("scroll-content");
  let isDragging = false;
  let startX, startY, scrollLeft, scrollTop;

  // マウスダウン（ドラッグ開始）
  container.addEventListener("mousedown", (e) => {
    isDragging = true;
    container.style.cursor = "grabbing";
    startX = e.pageX - container.offsetLeft;
    startY = e.pageY - container.offsetTop;
    scrollLeft = container.scrollLeft;
    scrollTop = container.scrollTop;
  });

  // マウスムーブ（ドラッグ中）
  container.addEventListener("mousemove", (e) => {
    if (!isDragging) return;
    e.preventDefault();
    const x = e.pageX - container.offsetLeft;
    const y = e.pageY - container.offsetTop;
    const walkX = (x - startX) * -1; // スクロール方向を逆に
    const walkY = (y - startY) * -1;
    container.scrollLeft = scrollLeft + walkX;
    container.scrollTop = scrollTop + walkY;
    addHiddenClass();
  });

  // マウスアップ（ドラッグ終了）
  container.addEventListener("mouseup", () => {
    isDragging = false;
    container.style.cursor = "grab";
  });

  // マウスが外に出た場合も終了
  container.addEventListener("mouseleave", () => {
    isDragging = false;
    container.style.cursor = "grab";
  });

  // タッチ対応（モバイル用）
  container.addEventListener("touchstart", (e) => {
    isDragging = true;
    startX = e.touches[0].pageX - container.offsetLeft;
    startY = e.touches[0].pageY - container.offsetTop;
    scrollLeft = container.scrollLeft;
    scrollTop = container.scrollTop;
    addHiddenClass();
  });

  container.addEventListener("touchmove", (e) => {
    if (!isDragging) return;
    e.preventDefault();
    const x = e.touches[0].pageX - container.offsetLeft;
    const y = e.touches[0].pageY - container.offsetTop;
    const walkX = (x - startX) * -1;
    const walkY = (y - startY) * -1;
    container.scrollLeft = scrollLeft + walkX;
    container.scrollTop = scrollTop + walkY;
  });

  container.addEventListener("touchend", () => {
    isDragging = false;
  });

  // スクロール対応（ホイールイベント）
  container.addEventListener("wheel", (e) => {
    e.preventDefault(); // デフォルトのスクロール動作を無効化
    const deltaX = e.deltaX; // 横方向のスクロール量
    const deltaY = e.deltaY; // 縦方向のスクロール量

    // スクロール量を適用
    container.scrollLeft += deltaX;
    container.scrollTop += deltaY;
    addHiddenClass();
  });
  function onHover() {
    const hoverTarget = document.querySelectorAll(".js-hover");
    hoverTarget.forEach((target) => {
      target.addEventListener("mouseover", () => {
        target.classList.add("is-hover");
      });
      target.addEventListener("mouseout", () => {
        target.classList.remove("is-hover");
      });
    });
  }
  onHover();
  window.addEventListener("mousemove", (e) => {
    const { clientX, clientY } = e;
    const x = Math.round((clientX / window.innerWidth) * 100);
    const y = Math.round((clientY / window.innerHeight) * 100);
    gsap.to(".light", {
      "--x": `${x}%`,
      "--y": `${y}%`,
    });
  });

  class CircularLightEffect {
    constructor(element) {
      this.element = element;
      this.isVisible = false;
      this.currentOpacity = 0;
      this.pulsePhase = 0;

      // オリジナルのスタイルを保存
      this.originalPosition = window.getComputedStyle(element).position;

      // 固定サイズを設定
      this.FIXED_SIZE = Math.min(element.offsetWidth * 1.5, element.offsetHeight * 1.5);

      // Canvasの設定
      this.canvas = document.createElement("canvas");
      this.canvas.className = "light-effect-canvas";
      this.ctx = this.canvas.getContext("2d");

      // Canvasのスタイルを設定
      Object.assign(this.canvas.style, {
        position: "absolute",
        top: "50%",
        left: "50%",
        transform: "translate(-50%, -60%)",
        pointerEvents: "none",
        zIndex: "0",
      });

      // Canvasのサイズ設定（Retina対応）
      this.canvas.width = this.FIXED_SIZE * 2.5;
      this.canvas.height = this.FIXED_SIZE * 2.5;
      this.canvas.style.width = `${this.FIXED_SIZE}px`;
      this.canvas.style.height = `${this.FIXED_SIZE}px`;

      // 要素のスタイル設定
      if (this.originalPosition === "static") {
        this.element.style.position = "relative";
      }

      // overflow設定の保存
      const originalOverflow = window.getComputedStyle(element).overflow;
      if (originalOverflow !== "hidden") {
        this._originalOverflow = originalOverflow;
      }

      // Canvasを要素に追加
      element.appendChild(this.canvas);

      // イベントハンドラーのバインド
      this._handleMouseEnter = this._handleMouseEnter.bind(this);
      this._handleMouseLeave = this._handleMouseLeave.bind(this);
      this._handleIntersection = this._handleIntersection.bind(this);

      // デバイスタイプの検出
      this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

      if (this.isMobile) {
        // モバイルの場合はIntersection Observerを設定
        this.observer = new IntersectionObserver(this._handleIntersection, {
          threshold: 0.5, // 50%以上表示された時にトリガー
        });
        this.observer.observe(element);
      } else {
        // PCの場合はマウスイベントを設定
        element.addEventListener("mouseenter", this._handleMouseEnter);
        element.addEventListener("mouseleave", this._handleMouseLeave);
      }

      // アニメーション開始
      this.animate();
    }

    _handleIntersection(entries) {
      entries.forEach((entry) => {
        this.isVisible = entry.isIntersecting;
      });
    }

    _handleMouseEnter() {
      this.isVisible = true;
    }

    _handleMouseLeave() {
      this.isVisible = false;
    }

    drawLight(time) {
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

      const targetOpacity = this.isVisible ? 0.6 : 0;
      this.currentOpacity += (targetOpacity - this.currentOpacity) * 0.1;

      if (this.currentOpacity > 0.01) {
        this.pulsePhase = (time / 700) % (2 * Math.PI);
        const pulseScale = 1 + Math.sin(this.pulsePhase) * 0.15;

        const centerX = this.canvas.width / 2;
        const centerY = this.canvas.height / 2;
        const maxRadius = this.FIXED_SIZE * 0.8 * pulseScale;

        // メインの光の円
        const mainGradient = this.ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, maxRadius * 2);

        mainGradient.addColorStop(0, `rgba(255, 255, 255, ${this.currentOpacity})`);
        mainGradient.addColorStop(0.3, `rgba(255, 255, 255, ${this.currentOpacity * 0.7})`);
        mainGradient.addColorStop(0.6, `rgba(255, 255, 255, ${this.currentOpacity * 0.3})`);
        mainGradient.addColorStop(1, "rgba(255, 255, 255, 0)");

        this.ctx.save();
        this.ctx.beginPath();
        this.ctx.fillStyle = mainGradient;
        this.ctx.filter = "blur(30px)";
        this.ctx.arc(centerX, centerY, maxRadius, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.restore();

        // 内側の明るい部分
        const innerGradient = this.ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, maxRadius);

        innerGradient.addColorStop(0, `rgba(255, 255, 220, ${this.currentOpacity * 0.8})`);
        innerGradient.addColorStop(0.4, `rgba(255, 255, 180, ${this.currentOpacity * 0.4})`);
        innerGradient.addColorStop(1, "rgba(255, 255, 255, 0)");

        this.ctx.save();
        this.ctx.beginPath();
        this.ctx.fillStyle = innerGradient;
        this.ctx.filter = "blur(15px)";
        this.ctx.arc(centerX, centerY, maxRadius * 0.7, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.restore();

        // 中心の輝点
        const glowGradient = this.ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, maxRadius * 0.3);

        glowGradient.addColorStop(0, `rgba(255, 255, 255, ${this.currentOpacity * 0.9})`);
        glowGradient.addColorStop(1, "rgba(255, 255, 255, 0)");

        this.ctx.save();
        this.ctx.beginPath();
        this.ctx.fillStyle = glowGradient;
        this.ctx.filter = "blur(5px)";
        this.ctx.arc(centerX, centerY, maxRadius * 0.2, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.restore();
      }
    }

    animate(time) {
      this.drawLight(time);
      requestAnimationFrame((t) => this.animate(t));
    }

    destroy() {
      if (this.isMobile) {
        this.observer.disconnect();
      } else {
        this.element.removeEventListener("mouseenter", this._handleMouseEnter);
        this.element.removeEventListener("mouseleave", this._handleMouseLeave);
      }

      this.canvas.remove();

      if (this.originalPosition === "static") {
        this.element.style.position = "static";
      }

      if (this._originalOverflow) {
        this.element.style.overflow = this._originalOverflow;
      }
    }
  }

  // 使用例
  function initLightEffects() {
    const effects = new Map();

    document.querySelectorAll(".js-spotlight").forEach((element) => {
      effects.set(element, new CircularLightEffect(element));
    });

    return function cleanup() {
      effects.forEach((effect) => effect.destroy());
      effects.clear();
    };
  }

  const cleanupLightEffects = initLightEffects();
</script>
