---
interface Props {
  title: string;
  description?: string;
}

const { title, description = "Astro テンプレート" } = Astro.props;
---

<!doctype html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content={description} />
    <title>{title}</title>
    <script is:inline>
      (function (d) {
        var config = {
            kitId: "lor3yjd",
            scriptTimeout: 3000,
            async: true,
          },
          h = d.documentElement,
          t = setTimeout(function () {
            h.className = h.className.replace(/\bwf-loading\b/g, "") + " wf-inactive";
          }, config.scriptTimeout),
          tk = d.createElement("script"),
          f = false,
          s = d.getElementsByTagName("script")[0],
          a;
        h.className += " wf-loading";
        tk.src = "https://use.typekit.net/" + config.kitId + ".js";
        tk.async = true;
        tk.onload = tk.onreadystatechange = function () {
          a = this.readyState;
          if (f || (a && a != "complete" && a != "loaded")) return;
          f = true;
          clearTimeout(t);
          try {
            Typekit.load(config);
          } catch (e) {}
        };
        s.parentNode.insertBefore(tk, s);
      })(document);
    </script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Zen+Kaku+Gothic+New&display=swap" rel="stylesheet">
  </head>
  <body>
    <main id="swup">
      <slot />
    </main>
    <!-- トランジション用SVG -->
    <svg class="transition-overlay" viewBox="0 0 100 100" preserveAspectRatio="none">
      <path class="transition-path1" d="M 0 0 V 0 Q 50 0 100 0 V 0 z"></path>
      <path class="transition-path2" d="M 0 0 V 0 Q 50 0 100 0 V 0 z"></path>
      <path class="transition-path3" d="M 0 0 V 0 Q 50 0 100 0 V 0 z"></path>
    </svg>
    <!-- detail間遷移用オーバーレイ -->
    <div class="js-detail-page-out"></div>
    <div class="js-detail-page-in"></div>
    <span class="js-mouse-stalker" style="opacity: 0;">
      <span class="hero__work__thumbnail js-mouse-stalker__cursor"> </span>
    </span>
    <!-- テクスチャホバー用SVGマウスストーカー -->
    <svg id="texture-mouse-stalker" class="js-texture-stalker">
      <circle id="texture-outer-circle" r="50" fill="#212121" stroke="#212121" stroke-width="1" />
      <text id="texture-stalker-text" text-anchor="middle" dominant-baseline="middle" fill="#fff">view more</text>
    </svg>
  </body>
</html>

<script>
  import Swup from "swup";
  import SwupJsPlugin from "@swup/js-plugin";
  import SwupHeadPlugin from "@swup/head-plugin";
  import gsap from "gsap";

  // SVGパス要素を取得
  const path1 = document.querySelector(".transition-path1") as SVGPathElement;
  const path2 = document.querySelector(".transition-path2") as SVGPathElement;
  const path3 = document.querySelector(".transition-path3") as SVGPathElement;

  // SVGパスの状態
  const F = "M 0 100 V 150 Q 50 50 100 150 V 100 z"; // 画面外下部（開始）
  const E = "M 0 100 V 0 Q 50 -1 100 0 V 100 z"; // 画面全体を覆う
  const G = "M 0 0 V 150 Q 50 50 100 150 V 0 z"; // 画面を覆った状態
  const H = "M 0 0 V 0 Q 50 0 100 0 V 0 z"; // 画面外上部（消えた状態）

  // 色の組み合わせセット
  const colorSets: [string, string, string][] = [
    ["#d71e7b", "#ff4d9d", "#ffb3d9"], // ピンク系
    ["#1e90ff", "#4da6ff", "#b3d9ff"], // 青系
    ["#2ecc71", "#58d68d", "#abebc6"], // 緑系
    ["#9b59b6", "#bb8fce", "#d7bde2"], // 紫系
    ["#f39c12", "#f7dc6f", "#fdebd0"], // オレンジ・黄色系
    ["#e74c3c", "#f1948a", "#fadbd8"], // 赤系
  ];

  // ランダムに色の組み合わせを取得
  function getRandomColors(): [string, string, string] {
    const index = Math.floor(Math.random() * colorSets.length);
    return colorSets[index];
  }

  // パスの色を更新する関数
  function updatePathColors(colors: [string, string, string]) {
    path1.setAttribute("fill", colors[0]);
    path2.setAttribute("fill", colors[1]);
    path3.setAttribute("fill", colors[2]);
  }

  // 遷移方向の検出
  let transitionDirection: "forward" | "backward" = "forward";
  // スクロール位置を保存（out時に保存してin時に使用）
  let savedScrollY = 0;

  // capture: true でSwupより先にイベントをキャプチャ
  document.addEventListener(
    "click",
    (e) => {
      const link = (e.target as HTMLElement).closest("a");
      if (link && link.href.includes("/detail/")) {
        // リンクのdata-direction属性を参照
        const direction = link.dataset.direction as "forward" | "backward" | undefined;
        transitionDirection = direction || "forward";
      }
    },
    { capture: true }
  );

  const swup = new Swup({
    plugins: [
      new SwupHeadPlugin(),
      new SwupJsPlugin({
        animations: [
          // detail配下のページ遷移: 前ページの上に次ページが半円で覆いかぶさる
          {
            from: "/detail/:path*",
            to: "/detail/:path*",
            out: async () => {
              // 古いページをクローンして背景として保持
              const page = document.querySelector("#swup") as HTMLElement;
              if (!page) return;

              // 現在のスクロール位置を保存
              savedScrollY = window.scrollY;

              // ページ全体をクローン
              const clone = page.cloneNode(true) as HTMLElement;
              clone.id = "swup-backdrop";
              clone.style.cssText = `
                position: fixed;
                top: ${-savedScrollY}px;
                left: 0;
                width: 100%;
                z-index: 90;
                pointer-events: none;
              `;
              document.body.appendChild(clone);
            },
            in: async () => {
              const page = document.querySelector("#swup") as HTMLElement;
              const backdrop = document.querySelector("#swup-backdrop") as HTMLElement;
              if (!page) return;

              // 画面の高さを基準にした半円の縦半径
              const vh = window.innerHeight / 2;

              // アニメーション中はposition: fixedでトップから表示
              page.style.position = "fixed";
              page.style.top = "0";
              page.style.left = "0";
              page.style.width = "100%";

              // チラつき防止：即座にclip-pathを適用
              const initialClipPath =
                transitionDirection === "forward"
                  ? `ellipse(0px ${vh}px at 0% ${vh}px)` // 次へ: 左端から
                  : `ellipse(0px ${vh}px at 100% ${vh}px)`; // 前へ: 右端から
              page.style.clipPath = initialClipPath;

              const tl = gsap.timeline();

              if (transitionDirection === "forward") {
                // 次へ: 左端から半円状に出現
                await tl.to(page, {
                  duration: 2,
                  clipPath: `ellipse(150% ${vh + 300}px at 100% ${vh}px)`,
                  ease: "power2.out",
                });
              } else {
                // 前へ: 右端から半円状に出現
                await tl.to(page, {
                  duration: 2,
                  clipPath: `ellipse(150% ${vh + 300}px at 0% ${vh}px)`,
                  ease: "power2.out",
                });
              }

              // アニメーション完了後、元のスタイルに戻す
              page.style.position = "";
              page.style.top = "";
              page.style.left = "";
              page.style.width = "";
              page.style.clipPath = "";

              // クローンを削除
              if (backdrop) backdrop.remove();
            },
          },

          // デフォルト（その他のページ遷移）
          {
            from: "(.*)",
            to: "(.*)",
            out: async () => {
              // ランダムな色を適用
              const colors = getRandomColors();
              updatePathColors(colors);

              // 離脱アニメーション：下から波が覆う
              const tl = gsap.timeline();
              await tl
                .set(path1, { attr: { d: F } })
                .set(path2, { attr: { d: F } })
                .set(path3, { attr: { d: F } })
                .to(path1, { duration: 0.6, attr: { d: E }, ease: "power3.inOut" })
                .to(path2, { duration: 0.6, attr: { d: E }, ease: "power3.inOut" }, "-=0.45")
                .to(path3, { duration: 0.6, attr: { d: E }, ease: "power3.inOut" }, "-=0.45");
            },
            in: async () => {
              // 入場アニメーション：上へ波が抜ける
              const tl = gsap.timeline();
              await tl
                .set(path1, { attr: { d: G } })
                .set(path2, { attr: { d: G } })
                .set(path3, { attr: { d: G } })
                .to(path1, { duration: 0.6, attr: { d: H }, ease: "power3.inOut" })
                .to(path2, { duration: 0.6, attr: { d: H }, ease: "power3.inOut" }, "-=0.45")
                .to(path3, { duration: 0.6, attr: { d: H }, ease: "power3.inOut" }, "-=0.45");
            },
          },
        ],
      }),
    ],
  });

  (window as any).swup = swup;
  swup.hooks.on("page:view", () => {
    window.dispatchEvent(new Event("swup:pageview"));
  });
  // 離脱アニメーション開始時にマウスストーカーをリセット
  swup.hooks.on("animation:out:start", () => {
    const stalker = document.querySelector(".js-mouse-stalker");
    if (stalker) {
      stalker.classList.remove("is-hover");
      stalker.classList.remove("is-texture-hover");
    }
    // SVGマウスストーカーも非表示
    const textureStalker = document.querySelector(".js-texture-stalker");
    if (textureStalker) {
      textureStalker.classList.remove("is-active");
    }
  });
  // アニメーション開始時にis-activeを追加
  swup.hooks.on("animation:in:start", () => {
    document.querySelector(".js-detail-page")?.classList.add("is-active");
  });
  // 初回ロード時にもis-activeを追加
  document.querySelector(".js-detail-page")?.classList.add("is-active");

  import "../scripts/main.js";
  import "../scripts/detailCanvas";
  import MouseStalker from "../assets/js/libs/Mosestalker";
  import observer from "../assets/js/libs/Observer.js";

  // マウスストーカー初期化
  function initMouseStalker() {
    new MouseStalker();
  }
  // マウスストーカーの状態をリセット
  function resetMouseStalker() {
    const stalker = document.querySelector(".js-mouse-stalker");
    const cursor = document.querySelector(".js-mouse-stalker__cursor") as HTMLElement;
    if (stalker) {
      stalker.classList.remove("is-hover");
      stalker.classList.remove("is-texture-hover");
    }
    if (cursor) {
      cursor.style.backgroundImage = "";
    }
    // SVGマウスストーカーもリセット
    const textureStalker = document.querySelector(".js-texture-stalker");
    if (textureStalker) {
      textureStalker.classList.remove("is-active");
    }
  }
  initMouseStalker();
  // swupページ遷移後に再初期化
  window.addEventListener("swup:pageview", () => {
    resetMouseStalker();
    initMouseStalker();
  });
  // observerを初期化する関数
  function initDetailObserver() {
    new observer(".js-detail", "detail-visible", false, {}, 200);
  }
  // 初回実行
  initDetailObserver();
  // swupページ遷移後に再実行
  window.addEventListener("swup:pageview", initDetailObserver);
  // スクロール遷移の設定
  const scrollNavigationMap: { [key: string]: string } = {
    "/detail/good_portforio": "/detail/sakaba",
    "/detail/sakaba": "/detail/sankou",
    "/detail/sankou": "/detail/page4",
    // 必要に応じて追加
  };

  let currentScrollHandler: (() => void) | null = null;

  // function initScrollNavigation() {
  //   // 前のハンドラーを削除
  //   if (currentScrollHandler) {
  //     window.removeEventListener("scroll", currentScrollHandler);
  //     currentScrollHandler = null;
  //   }

  //   const currentPath = window.location.pathname;
  //   const nextPage = scrollNavigationMap[currentPath];
  //   const prePage = Object.keys(scrollNavigationMap).find((key) => scrollNavigationMap[key] === currentPath);

  //   // 遷移先も前ページもない場合は何もしない
  //   if (!nextPage && !prePage) return;

  //   let hasNavigated = false;
  //   let lastScrollTop = window.scrollY || 0;

  //   currentScrollHandler = () => {
  //     if (hasNavigated) return;

  //     const scrollTop = window.scrollY || document.documentElement.scrollTop;
  //     const scrollHeight = document.documentElement.scrollHeight;
  //     const clientHeight = document.documentElement.clientHeight;
  //     const scrollingUp = scrollTop < lastScrollTop;

  //     // 最下部から100px以内に到達したら次のページへ
  //     if (nextPage && scrollTop + clientHeight >= scrollHeight - 100) {
  //       hasNavigated = true;
  //       if ((window as any).swup) {
  //         (window as any).swup.navigate(nextPage);
  //       } else {
  //         window.location.href = nextPage;
  //       }
  //     }
  //     // 上にスクロールして最上部に到達したら前のページへ
  //     else if (prePage && scrollTop <= 0 && scrollingUp) {
  //       hasNavigated = true;
  //       if ((window as any).swup) {
  //         (window as any).swup.navigate(prePage);
  //       } else {
  //         window.location.href = prePage;
  //       }
  //     }

  //     lastScrollTop = scrollTop;
  //   };
  //   window.addEventListener("scroll", currentScrollHandler);
  // }

  // // 初回実行
  // initScrollNavigation();
  // // Swupページ遷移後に再実行
  // window.addEventListener("swup:pageview", initScrollNavigation);
</script>
<style>
  .transition-overlay {
    position: fixed;
    top: 0;
    left: 0;
    z-index: 9999;
    width: 100%;
    height: 100%;
    pointer-events: none;
  }
</style>
